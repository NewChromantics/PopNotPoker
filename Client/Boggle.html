<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="win95.css" />
<style>
	/* disable scrolling on ios
	 https://stackoverflow.com/a/57489918/355753
	 */

body
{
	background:		#333;
}

#ToggleDebugButton
{
	/* make sure is displayed on top */
	position:	absolute;
	z-index:	101;
	background:	#eee;
}

.PacketDebug
{
	display:	none;
	
	position:	relative;
	z-index:	100;
}

#MoveButtonContainer
{
	background:	#aaa;
}

#CurrentState
{
	background:	#aaf;
}

#Prompt
{
	background:	var(--Yellow);
	position:	absolute;
	z-index:	4;
	top:		50vh;
	left:		50vw;
	transform: translate(-50%, -50%);
	padding:	3vmin;
	border:		1px solid var(--Black);
}
#Prompt span
{
	display:	block;
	margin-bottom:	3vmin;
}

#Debug
{
	background:	#afa;
}

#Error
{
	background:	#faa;
}

#GameWindow
{
	xxxopacity:	0.80;
	position:	absolute;
	left:		4vmin;
	top:		4vmin;
	right:		4vmin;
	bottom:		4vmin;
	xheight:		200px;
	xwidth:		200px;
}

#Minesweeper
{
	width:	100%;
	height:	100%;
}

#ChatWindow
{
	position:	absolute;
	bottom:		0vh;
	left:		0vw;
	width:		100vw;
}

:root
{
	--Black:		#000;
	--CellDefault:	var(--Yellow);
	--CellDisabled:	#dcc;
	--Yellow:		#fc1;
	--GridSize:		6;
	--BoardSize:	90vmin;
	--SelectionColour0:	#1f8;
	--SelectionColour1:	#1ef;
	--SelectionColour2:	#18f;
	--SelectionColour3:	#61f;
	--SelectionColour4:	#f1d;
	--SelectionColour5:	#f11;
}

#LetterBoard td
{
	--CellSize:		calc(var(--BoardSize)/var(--GridSize));
	background:		var(--CellDefault);
	width:			var(--CellSize);
	overflow:		hidden;
	font-size:		calc( var(--CellSize) * 0.8);
	font-family:	sans-serif;
	font-weight:	bold;
	text-transform:	uppercase;
	text-align:		center;
	color:			var(--Black);
}

/* any [other] */
#LetterBoard td[selectionindex]		{	background:		var(--SelectionColour5);	}
#LetterBoard td[selectionindex="0"]	{	background:		var(--SelectionColour0);	}
#LetterBoard td[selectionindex="1"]	{	background:		var(--SelectionColour1);	}
#LetterBoard td[selectionindex="2"]	{	background:		var(--SelectionColour2);	}
#LetterBoard td[selectionindex="3"]	{	background:		var(--SelectionColour3);	}
#LetterBoard td[selectionindex="4"]	{	background:		var(--SelectionColour4);	}
 
#LetterBoard
{
	position:	absolute;
	background:	var(--Black);
	width:		var(--BoardSize);
	height:		var(--BoardSize);
	bottom:		0vh;
	right:		0vw;
}

</style>
	<script src='PopEngineCommon/PopWebApi.js'></script>
	<script src='PopEngineCommon/PopApi.js'></script>
</head>
<body>
	<h1>Boggle</h1>	
	<div id=Prompt>
		<span>Prompt Here</span>
		<button id="PromptButton">Okay</button>
	</div>
	
	<button id="SubmitButton">Submit Word</button> <button id="SkipButton">Skip</button>
	
		<table id="LetterBoard">
			<tr>
				<td >a</td><td>b</td><td>c</td>
			</tr>
			<tr>
				<td>d</td><td>e</td><td>f</td>
			</tr>
			<tr>
				<td>g</td><td>h</td><td>i</td>
			</tr>
		</table>
	
	
	<script>
	
	
		let PopCardsModule;
		
		async function LoadAssets()
		{
			PopCardsModule = await import('./PopCards.js');
			
			await ShowActionMessage('Welcome to boggle!','ok');
		}
	
	
		//	if WaitFor is a string, we wait for a button press with that label
		//	if its a number, we yield for that time
		async function ShowActionMessage(Message,WaitFor)
		{
			const ActionBox = document.querySelector('#Prompt');
			const ActionText = document.querySelector('#Prompt span');
			const ActionButton = document.querySelector('#Prompt button');
			ActionText.innerText = Message;
			
			let WaitPromise;
			
			if ( typeof WaitFor == 'string' )
			{
				WaitPromise = WaitForButtonClick(ActionButton);
				ActionButton.innerText = WaitFor;
			}
			else 
			{
				if ( isNaN(WaitFor) )
					WaitFor = 3000;
				WaitPromise = Pop.Yield(WaitFor);
				HideElement(ActionButton);
			}
			
			ShowElement(ActionBox);
			const Result = await WaitPromise;
			
			Pop.Debug(`Action message clicked`);
			HideElement(ActionBox);
			HideElement(ActionButton);
			
			return Result;
		}
	
		let UserMapSelectionIndexes = [];
		let UserMapSelectionEnabled = false;
	
		function EnableUserSelection(Enable=true)
		{
			//	maybe push&pop user's selection here
			UserMapSelectionEnabled = Enable;
			
			const CellColour = Enable ? 'var(--Yellow)' : 'var(--CellDisabled)';
			document.documentElement.style.setProperty('--CellDefault', CellColour);
		}
		
		async function ShowSelectionSequence(MapSequence)
		{
			EnableUserSelection(false);
			ResetSelection();
			await Pop.Yield(500);
			for ( let MapIndex of MapSequence )
			{
				//	gr: this may need to ignore rules and just force it
				await OnClickedCell(MapIndex);
				await Pop.Yield(500);
			}
			await Pop.Yield(2000);
			ResetSelection();
		}
			
		function ResetSelection()
		{
			//	something has caused user to lose their selection
			UserMapSelectionIndexes = [];
			OnSelectionChanged();
		}
		
		function GetSelectionIndex(MapIndex)
		{
			const SelectionIndex = UserMapSelectionIndexes.indexOf(MapIndex);
			if ( SelectionIndex < 0 )
				return null;
			return SelectionIndex;
		}
		
		function OnClickedCell(MapIndex)
		{
			//	todo: if not linked, reset selection
			//	todo: if not linked, dont allow?

			//	if already selected, remove
			if ( GetSelectionIndex(MapIndex) !== null )
			{
				UserMapSelectionIndexes = UserMapSelectionIndexes.filter( i => i!=MapIndex );
			}
			else
			{
				UserMapSelectionIndexes.push(MapIndex);
			}
			OnSelectionChanged();
		}
		
		function OnSelectionChanged()
		{
			//	update cell graphics
			const Table = document.querySelector('#LetterBoard');
			const MapWidth = Table.rows[0].cells.length;

			function SetCell(x,y,Cell)
			{
				const Index = x + (y*MapWidth);
				const SelectionIndex = GetSelectionIndex(Index);
				SetCellSelected(Cell,SelectionIndex);
			}
			
			for ( let r=0;	r<Table.rows.length;	r++ )
			{
				const Row = Table.rows[r];
				for ( let c=0;	c<Row.cells.length;	c++ )
				{
					const Cell = Row.cells[c];
					SetCell( c, r, Cell );
				}
			}
		}
		
		function SetCellSelected(Cell,Index)
		{
			Pop.Debug(`SetCellSelected ${Cell}=${Index}`);
			if ( Index === null || Index === false || Index === undefined )
				Cell.removeAttribute('SelectionIndex');
			else
				Cell.setAttribute('SelectionIndex',Index);
		}
	
	
		function UpdateLetterBoard(Cells,Width)
		{
			function InitCell(x,y,Cell)
			{
				const Index = x + (y*Width);

				function OnClicked()
				{
					if ( !UserMapSelectionEnabled )
					{
						Pop.Warning(`User click whilst disabled`);
						return;
					}
					OnClickedCell(Index);
				}

				const Value = Cells[Index];
				Cell.innerText = Value;
				Cell.onclick = OnClicked;
			}
		
			const ColCount = Width;
			const RowCount = Math.floor(Cells.length / Width);
			const Table = document.querySelector('#LetterBoard');
			//	reduce amount of DOM changes
			let MakeNewTable = false;
			if ( Table.rows.length != RowCount )
				MakeNewTable = true;
			for ( let Row of Table.rows )
				if ( Row.cells.length != Width )
					MakeNewTable = true;
			
			if ( MakeNewTable )
			{
				ResetSelection();
				while ( Table.rows.length )
					Table.deleteRow(0);
				for ( let r=0;	r<RowCount;	r++ )
				{
					const Row = Table.insertRow();
					for ( let c=0;	c<ColCount;	c++ )
					{
						const Cell = Row.insertCell();
					}
				}
			}
			
			OnSelectionChanged();
			//	update contents
			{
				for ( let r=0;	r<Table.rows.length;	r++ )
				{
					const Row = Table.rows[r];
					for ( let c=0;	c<ColCount;	c++ )
					{
						const Cell = Row.cells[c];
						InitCell( c, r, Cell );
					}
				}
			}
		}
	
		async function SetState(State)
		{
			//	update game board & scores
			Pop.Debug(`SetState`,State);

			//	make sure table is correct
			UpdateLetterBoard(State.Map,State.MapWidth);
		}
				
		//	action done by someone registered on server
		async function ShowAction(Action)
		{
			//	gr: need to catch when this is a message for this player
			if ( Action.BadMove )
			{
				const Message = `Try Again: ${Action.BadMove}`;
				await ShowActionMessage(Message,'ok');
			}
			else if ( Action.MapSequence )
			{
				//	someone played a word
				await ShowSelectionSequence(Action.MapSequence);
			}
			else
			{
				await ShowActionMessage( JSON.stringify(Action), 4000 );
			}
		}
	
		function GetElement(ElementOrSelector)
		{
			let Element = ElementOrSelector;
			if ( typeof ElementOrSelector != 'string' )
				return Element;
			
			Element = document.querySelector(ElementOrSelector);
			if ( Element )
				return Element;
			
			//	try as id
			Element = document.querySelector(`#${ElementOrSelector}`);
			if ( Element )
				return Element;
				
			throw `Failed to find element matching ${ElementOrSelector}`;
		}
					
		function ShowElement(ElementOrSelector)
		{
			const Element = GetElement(ElementOrSelector);
			Element.style.visibility = 'visible';
		}
	
		function HideElement(ElementOrSelector)
		{
			const Element = GetElement(ElementOrSelector);
			Element.style.visibility = 'hidden';
		}
	
		function HideActionButtons()
		{
			HideElement('SkipButton');
			HideElement('SubmitButton');
		}
	
		async function WaitForButtonClick(ButtonSelector,ReturnValue=undefined)
		{
			if ( ReturnValue === undefined )
				ReturnValue = ButtonSelector;
			const Element = GetElement(ButtonSelector);
			const Promise = Pop.CreatePromise();
			Element.onclick = Promise.Resolve;
			ShowElement(ButtonSelector);
			await Promise;
			return ReturnValue;
		}
	
		async function WaitForSkip()
		{
			//	show skip button
			//	wait for it to be clicked
			await WaitForButtonClick(`#SkipButton`);
			//	hide all others when done
			HideActionButtons();
			
			return 'Skip';	//	just for debugging
		}
		
		async function WaitForMapSequence()
		{
			//	let player select tiles
			EnableUserSelection();
			
			//	wait for player to click submit button
			await WaitForButtonClick(`#SubmitButton`);
			//	return letter indexes
			let SelectedIndexes = UserMapSelectionIndexes.slice();
			//	hide other buttons
			HideActionButtons();
			
			ResetSelection();
			
			return SelectedIndexes;
		}
	
	</script>
</body>

